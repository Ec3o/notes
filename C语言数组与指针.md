# C语言数组与指针

## 数组

### 初始化数组

#### 创建数组

```;
int states[50];
float candy[365];
char code[12];
```

基本格式:

```C
<type> <name>[<length>];
```

初始化数组并赋值:

```C
int powers[8] = {1,2,4,6,8,16,32,64};
```

使用**const**声明只读数组(数组常量):

```C
const int days[MONTH]={31,28,31,30,31,30,31,31,30,31,30,31}
```

编译器会按照数组给定的数据从头开始赋值.当给出的数据少于数组长度时,未提供数据的部分往往会被赋为默认值( **0** );当给出的数据多于数组长度时,编译器会报错.当然,我们可以省略数组长度让其自主判断数组长度.

```c
sizeof <name>
```

会得到数组的大小.

```C
sizeof <name>[index]
```

会得到单个数据的大小.

```C
sizeof <name> / sizeof <name>[index]
```

会得到数组的长度.

#### 新的初始化方式

```C
int arr[6]={0,0,0,0,0,212};//常规初始化方法
int arr[6]={[5]=212};//把arr[5]初始化为212
```

来看一点复杂的初始化:

```C
int days[MONTH]={31,28,[4]=31,30,31,[1]=29};
```

赋值后数组元素值如下所示:

```C
{31,29,0,0,31,30,31,0,0,0,0,0}
```

如何理解这个赋值?很简单.

**31->days[0]**

**28->days[1]**

**31->days[4]**

**30->days[5]**

**31->days[6]**

**29->days[1]**

**0->days[2,3,7,8,9,10,11]**

原理就是这样.跳转赋值后,会从跳转后的索引继续向后连续赋值.(被赋值的数组元素也可以被再次赋值)

### 变长数组

可以使用变量作为数组的长度,但这不意味着数组的大小在初始化后会发生改变.数组的大小一旦确定,便无法更改.

### 数组使用

#### 警惕下标越界

在C语言中,使用越界下标的结果是未定义的.产生的结果可能是内存中系统任意初始化的结果,会导致"**不可预测**"的错误.编译器不会检查数组下标是否使用得当.数组编号从0开始

### 二维数组

```c
float rain[5][12];
```

这定义了一个二维数组:可以理解为:**rain[5]**

而对于rain[0]-rain[4]来说,每一个数组元素是一个数组[12],一个有12个元素的数组.

## 指针

### 数组名与指针初始化

我们定义了一个数组data[50].当我们调用data时,实际调用的是data的地址.

```C
a=*(data+5);//a的值是data[5]的值
b=*data+5;//b的值是data[0]的值+5
```

切勿混淆它们的关系.data+index是元素data[index]的地址,而*(data+index)则是代表该指针指向的值.

小语法补充:

```C
b=a++;//先取a的值,a再自增1
b=++a;//a先自增1,再取a的值
```

定义一个指针变量:

```C
int *ar=a;
```

这样,我们就定义了一个指针变量ar,它指向变量a.当我们修改*ar时,我们输出变量a的值也会不同.

取地址符号`&`和解引用符号`*` 常常搭配使用.

### 野指针

未被初始化的指针称为野指针.解引用野指针是十分危险的行为.

```C
int *pt;
*pt=5;
```

我们至今为止未能知晓5去了哪里.它有可能占据了别的变量的值,也有可能代替了一些函数产生了未知错误.总之,在使用指针时必须伴随着指针的初始化,否则程序可能会出现未知的错误.

### 恰当使用const

有的时候我们需要使用函数来改变原始数据的值,而在这个过程中我们可能会用到指针,下面是一个实例:

```C
double prices[100];
void add_to(double ar[], int n,double val)
{
	int i;
	for(i=0;i<n;i++)
		ar[i]+=val;
}
add_to(prices,100,2.50);
```

这个函数执行后,prices数组的每一个元素都增加了2.50,修改会直接作用在原数组上.

当然,有些时候我们不需要修改数组元素.数组往往是只读的.

```C
int sum(int ar[],int n)
{
	int i;
	int total=0;
	for( i=0 ;i<n;i++)
		total+=ar[i]++;
	return total;
}
```

在上面的代码中,使用ar[i]++会改变原数组的内容.为了避免这种错误发生,可以使用const固定指针.

```C
int sum(const int ar[],int n)
{
	int i;
	int total=0;
	for( i=0 ;i<n;i++)
		total+=ar[i];
	return total;
}
```

在下面的修改过的代码中使用ar[i]++会报错,原因是const变量的值不允许改变.

### 二维数组の指针

```C
int zippo[4][2];
zippo<-二维数组首元素地址(第一个一维数组&第一个一维数组的第一个元素)
zippo+2<-二维数组第三个元素地址(第三个一维数组)
*(zippo+2)<-二维数组第三个元素(第三个一维数组)首元素地址
*(zippo+2)+1<-二维数组第三个元素(第三个一维数组)第二个元素(第三个一维数组第二个元素)地址
*(*(zippo+2)+1)<-二维数组第三个元素(第三个一维数组)第二个元素(第三个一维数组第二个元素)值
```

### 指针的指向对象

万物.如果你也是计算机程序的一部分,你也可以被指向,就连指针自己也是如此.指向指针的指针称为二级指针,例如下面这个例子:

```C
int* p="link Start!";
int** pp=&p;
```

int*,int**是类型,与解引用无关,切勿混淆.

### 指针的作用域

局部作用域可以访问到该局部的外部作用域，但是无法访问同级的其他作用域；而
在局部作用域内创建的局部变量在离开局部作用域后就会被销毁。局部作用域一般
以大括号为界。
